# Design: WASM Species Linker

## Context

Species name parsing is required for auto-linking in markdown content. This design uses a Rust parser compiled to WebAssembly, enabling client-side linking at render time rather than server-side linking at save time.

### Why Rust + WASM

The species name grammar is regular (no recursion), but parsing it correctly involves:

1. **Multiple infraspecific ranks**: 20+ rank abbreviations (var., subsp., f., nothovar., etc.)
2. **The `f.` disambiguation**: `f.` means both "forma" (rank) and "filius" (author suffix)
3. **Author citation patterns**: Complex but finite set of patterns
4. **Scanning prose**: Skip existing links, code blocks, URLs

Go's regexp lacks lookahead (RE2 engine), making disambiguation awkward. Rust's `nom` library provides cleaner parser combinator patterns with explicit backtracking control.

### Why Client-Side

| Aspect | Server-side (save time) | Client-side (render time) |
|--------|-------------------------|---------------------------|
| Stored content | Contains `[Q. alba](/species/alba)` | Contains `Q. alba` |
| Species rename | Breaks existing links | Links always current |
| Offline | Works (pre-embedded) | Works (WASM + IndexedDB) |
| Backlinks | Grep stored content | Need separate index |

Client-side linking keeps stored content clean and links always fresh.

### Stakeholders

- Web app (primary: render-time linking)
- iOS app (future: same WASM artifact)
- API server (optional: backlinks indexing via wazero)

### Constraints

- WASM artifact must be <100KB for reasonable load time
- Browser must have species list available (already in IndexedDB)
- Must handle all ICN name forms from `add-species-name-parser` spec

## Goals / Non-Goals

### Goals

- Parse all ICN-compliant oak species name forms (same as Go parser spec)
- Compile to compact WASM artifact
- Provide JavaScript bindings for browser use
- Enable iOS reuse via JavaScriptCore or Wasmer
- Return structured parse results with position information

### Non-Goals

- Parsing non-oak genera (only `Quercus`/`Q.`)
- Server-side link embedding (that's the other proposal)
- Full ICN compliance for all plant families
- Handling OCR errors or typos

## Decisions

### Decision: Parser Library

**Decision**: Use `nom` parser combinators.

```rust
use nom::{
    branch::alt,
    bytes::complete::{tag, tag_no_case, take_while1},
    combinator::{opt, map},
    sequence::{tuple, preceded},
    IResult,
};

fn genus(input: &str) -> IResult<&str, &str> {
    alt((tag("Quercus"), tag("Q.")))(input)
}

fn hybrid_marker(input: &str) -> IResult<&str, bool> {
    map(opt(alt((tag("×"), tag_no_case("x")))), |o| o.is_some())(input)
}

fn epithet(input: &str) -> IResult<&str, &str> {
    take_while1(|c: char| c.is_ascii_lowercase() || c == '-')(input)
}
```

**Rationale**: `nom` provides composable, testable parsers with explicit backtracking. Each sub-parser is independently testable. Pattern matching on results is clean.

### Decision: WASM Target

**Decision**: Use `wasm32-unknown-unknown` target with `wasm-bindgen`.

```toml
# Cargo.toml
[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
wasm-bindgen = "0.2"
nom = "7"
serde = { version = "1", features = ["derive"] }
serde-wasm-bindgen = "0.6"

[profile.release]
opt-level = "z"     # Optimize for size
lto = true          # Link-time optimization
```

Build with: `wasm-pack build --target web --release`

Expected size: 50-80KB gzipped.

### Decision: JavaScript API

```typescript
// Generated by wasm-bindgen
export interface ParseResult {
    genus: string;
    species: string;
    isHybrid: boolean;
    infraspecific: { rank: string; epithet: string } | null;
    author: string;
    raw: string;
    start: number;
    end: number;
}

export function parseSpecies(text: string): ParseResult | null;
export function scanSpecies(text: string): ParseResult[];
```

### Decision: Resolver Pattern

The WASM parser only parses—it doesn't know about the database. Resolution happens in JavaScript:

```javascript
// web/src/lib/speciesLinker.js
import init, { scanSpecies } from 'rust-parser';

export async function linkSpecies(text, db) {
    await init();  // Load WASM once

    const mentions = scanSpecies(text);
    let result = text;

    // Process in reverse order to preserve positions
    for (const m of mentions.reverse()) {
        const entry = await db.species.get({ name: m.species });
        if (entry) {
            const link = `[${m.raw}](/species/${m.species})`;
            result = result.slice(0, m.start) + link + result.slice(m.end);
        }
    }

    return result;
}
```

**Rationale**: Keeps WASM parser pure and portable. Database access is platform-specific (Dexie in browser, different in iOS).

### Decision: The `f.` Disambiguation

In Rust, this is clean with `nom`:

```rust
fn forma_rank(input: &str) -> IResult<&str, &str> {
    // f. followed by lowercase = rank
    let (remaining, _) = tag_no_case("f")(input)?;
    let (remaining, _) = opt(tag("."))(remaining)?;
    let (remaining, _) = space1(remaining)?;
    let (remaining, epithet) = epithet(remaining)?;  // Must have epithet
    Ok((remaining, "f."))
}

fn author_f_suffix(input: &str) -> IResult<&str, &str> {
    // f. at end or followed by space + uppercase/connector = author suffix
    preceded(tag(".f"), alt((
        eof,
        peek(tuple((space1, satisfy(|c| c.is_uppercase())))),
        peek(tuple((space1, alt((tag("et"), tag("ex"), tag("in")))))),
    )))(input)
}
```

The key insight: `nom` lets you express "f. followed by lowercase epithet" vs "f. at word boundary" as separate parsers, then combine with `alt` trying in order.

### Decision: Skip Regions

Before scanning for species, identify regions to skip:

```rust
fn find_skip_regions(text: &str) -> Vec<(usize, usize)> {
    let mut regions = Vec::new();

    // Fenced code blocks: ```...```
    // Inline code: `...`
    // Markdown links: [...](...) and ![...](...)
    // URLs: http://... or https://...

    regions
}

fn scan_species(text: &str) -> Vec<ParseResult> {
    let skip = find_skip_regions(text);
    let mut results = Vec::new();

    // Find "Quercus" or "Q." occurrences
    for m in find_genus_markers(text) {
        if overlaps_any(&skip, m.start, m.end) {
            continue;
        }
        if let Some(parsed) = parse_at_position(text, m.start) {
            results.push(parsed);
        }
    }

    results
}
```

### Decision: Backlinks Index

Since stored content doesn't contain links, backlinks require a separate index:

```sql
-- Updated on content save (API parses but doesn't embed)
CREATE TABLE mentions (
    content_type TEXT NOT NULL,  -- 'article' or 'taxon'
    content_id TEXT NOT NULL,
    species_name TEXT NOT NULL,
    PRIMARY KEY (content_type, content_id, species_name)
);

CREATE INDEX idx_mentions_species ON mentions(species_name);
```

API flow on save:
1. Store raw content (no links)
2. Call WASM parser via wazero (or re-implement minimal parser in Go)
3. Update `mentions` table

Backlinks endpoint: `GET /api/v1/species/{name}/backlinks`

## Package Structure

```
rust-parser/
├── Cargo.toml
├── src/
│   ├── lib.rs           # WASM entry points
│   ├── grammar.rs       # Species name parsing (nom combinators)
│   ├── scanner.rs       # Text scanning, skip regions
│   └── types.rs         # ParseResult, Infraspecific
├── tests/
│   └── integration.rs   # Full parsing tests
└── pkg/                 # wasm-pack output (gitignored, built in CI)
    ├── rust_parser.js
    ├── rust_parser.d.ts
    └── rust_parser_bg.wasm

web/
└── src/lib/
    ├── speciesLinker.js    # Load WASM, resolve via Dexie
    └── wasmLoader.js       # Async WASM initialization
```

## Risks / Trade-offs

### Risk: WASM Load Time

- **Risk**: WASM module adds latency to first render
- **Mitigation**:
  - Optimize for size (`opt-level = "z"`, LTO)
  - Lazy load after initial page render
  - Cache in service worker

### Risk: Build Complexity

- **Risk**: CI needs Rust toolchain, wasm-pack
- **Mitigation**:
  - Commit built WASM artifact (controversial but simple)
  - Or: GitHub Actions with `rust-toolchain.toml`
  - Docker build stage with Rust

### Risk: Backlinks Require Separate Index

- **Risk**: Can't grep stored content for species mentions
- **Mitigation**:
  - `mentions` table updated on save
  - Acceptable complexity for cleaner storage

### Risk: iOS Integration Effort

- **Risk**: Using WASM in native iOS requires bridging
- **Mitigation**:
  - JavaScriptCore (built into iOS) can run WASM
  - Wasmer has Swift bindings
  - Or: recompile Rust to native iOS library (separate target)

## iOS WASM Options

### Option A: JavaScriptCore (Recommended)

iOS includes JavaScriptCore which supports WASM. Wrap parser in minimal JS:

```swift
let context = JSContext()!
let wasmBytes = loadWasmFromBundle()
context.evaluateScript(wasmLoaderJS)
context.setObject(wasmBytes, forKeyedSubscript: "wasmBytes")
let result = context.evaluateScript("parseSpecies('Q. alba')")
```

Pros: No external dependencies, uses same WASM artifact
Cons: JS bridge overhead, async handling awkward in Swift

### Option B: Wasmer Swift

```swift
import Wasmer

let module = try Module(filePath: "rust_parser.wasm")
let instance = try module.instantiate()
let result = try instance.call("parse_species", "Q. alba")
```

Pros: Native speed, no JS layer
Cons: External dependency, different API from browser

### Option C: Native Rust Library

Compile Rust to iOS targets directly (no WASM):

```bash
cargo build --target aarch64-apple-ios --release
```

Pros: Maximum performance, native integration
Cons: Separate build artifact, different from browser code path

**Recommendation**: Start with Option A (JavaScriptCore) for consistency with browser. Optimize to Option C if performance matters.

## Open Questions

1. ~~Should WASM be committed or built in CI?~~ Build in CI, cache aggressively.

2. **Backlinks implementation**: Use `mentions` table, or parse-on-demand for small corpus?

3. **iOS priority**: When does iOS app need species linking? Can defer bridging work.

## References

- [wasm-bindgen Guide](https://rustwasm.github.io/wasm-bindgen/)
- [nom Documentation](https://docs.rs/nom/latest/nom/)
- [Shrinking WASM Size](https://rustwasm.github.io/book/reference/code-size.html)
- [JavaScriptCore WASM](https://webkit.org/blog/7691/webassembly/)
- [Existing Rust parser](/jeffdc/gallformers/usda_plants/src/plant.rs) - Reference implementation
